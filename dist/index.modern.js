import{pascalCase as e}from"change-case";import{diffLines as t}from"diff";class r{constructor(){this._cache=new Map,this._cache_r=new Map,this._unnameCount=0}_printCache(){return this._cache_r.size>0?Array.from(this._cache_r.entries()).map(([e,t])=>`interface ${e}${t}`).join("\n"):""}parseToTypes(e,t="DefaultInterface"){if("object"!=typeof e)throw TypeError('param "obj" must be an object, but got '+typeof e);return`interface ${t}${this._parseObjectToTypes(e)}\n${this._printCache()}`}_parseObjectToTypes(e){return"{\n"+Object.entries(e).map(([e,t])=>{const r=function(e){return e.match(/^\d/)||e.match(/[\u0000-#%-/:-@[-^`{-\u007f]/)?`"${e}"`:e}(e);return`${r}:${this._typeof(t,r)}`}).join("\n")+"\n}"}_printArrayType(e){const t=new Set;for(const r of e)t.add(n(r));let r;for(const r of e)t.add(n(r));if(1==t.size&&t.has("Object")){t.clear();for(const r of e)t.add(this._checkThenParseObject(r));const n=Array.from(t);if(1==t.size)r=n.join(" | ");else{const e=n.map(e=>this._cache_r.get(e));let t=e[0],c=n[0];for(let s=1;s<e.length;s++){const o=a(t,e[s]);if(!o)return r=n.join(" | "),`Array<${r}>`;t=o,c=c.concat(n[s])}for(let t=0;t<e.length;t++)this._cache.set(e[t],{name:c}),this._cache_r.delete(n[t]);this._cache_r.set(c,t),r=c}}else r=0===e.length?"unknown":Array.from(t).join(" | ");return`Array<${r}>`}_checkThenParseObject(t,r){if(t instanceof Array)return this._printArrayType(t);if(null!=t){if(r){const e=this._tryParseIdMap(t,r);if(e)return e}const n=this._parseObjectToTypes(t);if(n.match(/{\s*}/))return n;const c=this._cache.get(n);if(c)return c.name;{let t,c=r?e(r.match(/^["']\d/)?"I"+r:r):this._defaultName();for(;t=this._cache_r.get(c);){const e=s(t,n);if(e){this._cache.set(e,{name:c}),this._cache.set(t,{name:c}),this._cache.set(n,{name:c}),this._cache_r.set(c,e);break}c=c.concat("_")}return this._cache_r.set(c,n),this._cache.set(n,{name:c}),c}}return"null"}_tryParseIdMap(e,t){const r=t,n=Array.from(Object.keys(e));if(n.length>0&&n.every(e=>e.match(/^\d+$/)))return`{[id:number]:${Array.from(new Set(Object.values(e).map(e=>this._typeof(e,r)))).join("|")}}`}_typeof(e,t){let r=typeof e;switch(r){case"object":return this._checkThenParseObject(e,t);case"undefined":case"boolean":case"number":case"string":return r;default:throw r+" isn't support yet."}}_defaultName(){return"I"+this._unnameCount++}}function n(e){let t=typeof e;switch(t){case"object":return"Object";case"undefined":case"boolean":case"number":case"string":return t;default:throw t+" isn't support yet."}}const c=e=>e.startsWith("{")&&e.endsWith("}");function s(e,t){if(c(e)&&c(t)){const[r,n,c]=o(e,t);if(r.length>=n.length+c.length)return i(r,n,c)}}const a=(e,t)=>i(...o(e,t));function o(e,r){const n=t(e.replaceAll(/^{|}/gm,""),r.replaceAll(/^{|}/gm,"")),c=[],s=[],a=[];for(const e of n)e.added?s.push(...h(e.value)):e.removed?a.push(...h(e.value)):c.push(...h(e.value));return[c,s,a]}function i(e,t,r){const n=Object.fromEntries(r);for(const[e]of t)if(n[e])return;return"{\n"+[...[...t,...r].map(([e,t])=>`${e}?:${t}`),...e.map(([e,t])=>`${e}:${t}`)].join("\n")+"\n}"}const h=e=>e.split("\n").filter(e=>""!=e).map(e=>e.split(":"));function f(e,t="DefaultInterface"){return(new r).parseToTypes(JSON.parse(e),t)}export{r as Json2Type,f as parseToTypes};
//# sourceMappingURL=index.modern.js.map
