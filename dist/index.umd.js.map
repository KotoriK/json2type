{"version":3,"file":"index.umd.js","sources":["../index.ts"],"sourcesContent":["/**\n * json2type\n * @author KotoriK\n * @date 2021.6\n * @license MIT\n */\nimport { pascalCase } from 'change-case'\nimport { diffLines } from 'diff'\ninterface InterfaceDefinition {\n    name: string\n}\nexport class Json2Type {\n    /**\n     * @private\n     * @type {Map<string,InterfaceDefinition>}\n     */\n    private _cache: Map<string, InterfaceDefinition> = new Map()\n    private _cache_r: Map<string, string> = new Map()\n    /**\n     * @private\n     * @type {number}\n     */\n    private _unnameCount: number = 0\n    private _printCache() {\n        if (this._cache_r.size > 0) {\n            const entries = Array.from(this._cache_r.entries())\n            return entries.map(([name, key]) => {\n                return `interface ${name}${key}`\n            }).join('\\n')\n        } else {\n            return ''\n        }\n    }\n    /**\n     * \n     * @param {Record<string,any>} obj \n     * @param {string} name\n     */\n    parseToTypes(obj: Record<string, any>, name: string = 'DefaultInterface') {\n        if (typeof obj !== 'object') throw TypeError('param \"obj\" must be an object, but got ' + typeof obj)\n        return `interface ${name}${this._parseObjectToTypes(obj)}\\n${this._printCache()}`\n    }\n    /**\n     * @private\n     * @param obj \n     * @returns {string}\n     */\n    private _parseObjectToTypes(obj: Object): string {\n        return '{\\n' + Object.entries(obj)\n            .map(([key, value]) => {\n                const safekey = wrapKey(key)\n                return `${safekey}:${this._typeof(value, safekey)}`\n            }\n            ).join('\\n') + '\\n}'\n    }\n    /**\n     * 推断数组内部元素的类型\n     * @private\n     * @param {Array} arr \n     * @returns {string}\n     */\n    private _printArrayType(arr: any[]): string {\n        const typesSet = new Set<string>()\n        for (const value of arr) {\n            typesSet.add(_typeOf_NoRecurse(value))\n        }\n        let T\n        for (const value of arr) {\n            typesSet.add(_typeOf_NoRecurse(value))\n        }\n        if (typesSet.size == 1 && typesSet.has('Object')) {\n            typesSet.clear()\n            for (const item of arr) {\n                typesSet.add(this._checkThenParseObject(item))\n            }\n            const types = Array.from(typesSet)\n            if (typesSet.size == 1) T = types.join(' | ')\n            else {\n                const structs = types.map(name => this._cache_r.get(name)) as string[] //值来自于前边返回，肯定在map中有登记\n                let majorStruct = structs[0]\n                let majorStructName = types[0]\n                for (let i = 1; i < structs.length; i++) {\n                    const trialStruct = structs[i]\n                    const result = mergeStruct(majorStruct, trialStruct)\n                    if (result) {\n                        majorStruct = result\n                        majorStructName = majorStructName.concat(types[i])\n                    } else {\n                        T = types.join(' | ')//如果类型不一样直接放弃合并\n                        return `Array<${T}>`\n                    }\n                }\n                for (let i = 0; i < structs.length; i++) {\n                    this._cache.set(structs[i], { name: majorStructName })\n                    this._cache_r.delete(types[i])\n                }\n                this._cache_r.set(majorStructName, majorStruct)\n                T = majorStructName\n            }\n        } else if (arr.length === 0) {\n            T = 'unknown'//空数组无法推断类型\n        } else {\n            T = Array.from(typesSet).join(' | ')\n        }\n        return `Array<${T}>`\n    }\n    /**\n     * @private\n     * @param foo \n     * @param key \n     * @returns \n     */\n    private _checkThenParseObject(foo: Object, key?: string) {\n        if (foo instanceof Array) {\n            return this._printArrayType(foo)\n        } else if (foo != null) {\n            if (key) {\n                const trial = this._tryParseIdMap(foo, key)\n                if (trial) return trial\n            }\n            const struct = this._parseObjectToTypes(foo, /* key */)\n            if (struct.match(/{\\s*}/)) return struct\n            const d = this._cache.get(struct)\n            if (d) {\n                return d.name\n            } else {\n                let name = key ? pascalCase(key.match(/^[\"']\\d/) ? (\"I\" + key) : key) : this._defaultName()\n                let structWithSameName: string | undefined\n                while (structWithSameName = this._cache_r.get(name)/*赋值表达式会返回赋予的值 */) {\n                    //是否可以合并\n                    const trialMerge = tryMergeStruct(structWithSameName, struct)\n                    if (trialMerge) {\n                        //填入新的记录\n                        this._cache.set(trialMerge, { name })\n                        //将两个结构重定向到新的结构\n                        this._cache.set(structWithSameName, { name })\n                        this._cache.set(struct, { name })\n                        this._cache_r.set(name, trialMerge)\n                        break//可以脱出循环了\n                    } else {\n                        //更名\n                        name = name.concat('_')\n                    }\n                }\n                this._cache_r.set(name, struct)\n                this._cache.set(struct, { name })\n                return name\n            }\n        }\n        return 'null'\n    }\n    /**\n     * try to parse Index Signatures Object\n     * @seealso https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures\n     * @param foo \n     * @param key \n     * @returns \n     */\n    private _tryParseIdMap(foo: Object, key: string) {\n        const parentKey = key\n        const keys = Array.from(Object.keys(foo))\n        if (keys.length > 0 && keys.every((item) => item.match(/^\\d+$/))) {\n            return `{[id:number]:${Array.from(\n                new Set(\n                    Object.values(foo)\n                        .map(value => this._typeof(value, parentKey))\n                )\n            )\n                .join('|')}}`\n        }\n    }\n    /**\n     * @private\n     * @param foo \n     * @param {string | undefined} key\n     * @returns {string}\n     */\n    private _typeof(foo: any, key: string): string {\n        let valueType = typeof foo\n        switch (valueType) {\n            case 'object':\n                return this._checkThenParseObject(foo, key)\n            /**按原样 */\n            case \"undefined\":\n            case 'boolean':\n            case 'number':\n            case \"string\":\n                return valueType\n            default:\n                throw valueType + \" isn't support yet.\"\n        }\n    }\n    /**\n     * @private\n     * @returns {string}\n     */\n    private _defaultName(): string {\n        return 'I' + this._unnameCount++\n    }\n}\n/**\n * @param foo \n * @returns {string}\n */\nfunction _typeOf_NoRecurse(foo: any): string {\n    let valueType = typeof foo\n    switch (valueType) {\n        case 'object':\n            return 'Object'\n        /**按原样 */\n        case \"undefined\":\n        case 'boolean':\n        case 'number':\n        case \"string\":\n            return valueType\n        default:\n            throw valueType + \" isn't support yet.\"\n    }\n}\n/**\n * 将key包裹成符合JavaScript标识符要求的格式\n * @param {string} key \n */\nfunction wrapKey(key: string) {\n    //数字打头的Key\n    if (key.match(/^\\d/)) {\n        return `\"${key}\"`\n    } else if (key.match(/[\\u0000-#%-/:-@[-^`{-\\u007f]/)) {//ASCII中没有ID_Start和ID_Continue也不是'$','_'的字符\n        return `\"${key}\"`\n    } else {\n        //非ASCII的用例太罕见，不做处理\n        return key\n    }\n}\n/**\n * 检查一个类型描述是不是描述一个详细的对象（即不object）\n * @param type \n */\nconst isTypeOfObject = (type: string) => type.startsWith('{') && type.endsWith('}')\n\nfunction tryMergeStruct(typeA: string, typeB: string) {\n    if (isTypeOfObject(typeA) && isTypeOfObject(typeB)) {\n        const [unchageFields, addedFields, removedFields] = diffStructs(typeA, typeB)\n        if (unchageFields.length >= (addedFields.length + removedFields.length)) {\n            return doMergeStruct(unchageFields, addedFields, removedFields)\n        }\n    }\n}\nconst mergeStruct = (typeA: string, typeB: string) => doMergeStruct(...diffStructs(typeA, typeB))\n\nfunction diffStructs(typeA: string, typeB: string) {\n    const changes = diffLines(typeA.replaceAll(/^{|}/mg, ''), typeB.replaceAll(/^{|}/mg, ''))\n    const unchageFields = [], addedFields = [], removedFields = []\n    for (const change of changes) {\n        if (change.added) addedFields.push(...parseBackToKeyValue(change.value))\n        else if (change.removed) removedFields.push(...parseBackToKeyValue(change.value))\n        else unchageFields.push(...parseBackToKeyValue(change.value))\n    }\n    return [unchageFields, addedFields, removedFields] as const\n}\nfunction doMergeStruct(unchageFields: string[][], addedFields: string[][], removedFields: string[][]) {\n    //检查类型是否相同\n    const mapRemoved = Object.fromEntries(removedFields)\n    for (const [key] of addedFields) {\n        const typeRemoved = mapRemoved[key]\n        if (typeRemoved/*  && typeRemoved != type */) {\n            return undefined\n        }\n    }\n    //removed和added的字段全部标记可选\n\n    return \"{\\n\" + [\n        ...[...addedFields, ...removedFields].map(([key, type]) => `${key}?:${type}`),\n        ...unchageFields.map(([key, type]) => `${key}:${type}`)\n    ]\n        .join('\\n') + \"\\n}\"\n}\n\nconst parseBackToKeyValue = (str: string) => str.split('\\n').filter(str => str != '').map(str => str.split(':'))\n\n/**\n * \n * @param {string} json\n * @param {string} name name of the generating interface \n */\nexport function parseToTypes(json: string, name: string = 'DefaultInterface') {\n    return new Json2Type().parseToTypes(JSON.parse(json), name)\n}\n"],"names":["Json2Type","_cache","Map","_cache_r","_unnameCount","_printCache","this","size","Array","from","entries","map","join","parseToTypes","obj","name","TypeError","_parseObjectToTypes","Object","key","value","safekey","match","_this","_typeof","_printArrayType","arr","T","typesSet","Set","add","_typeOf_NoRecurse","has","clear","_checkThenParseObject","types","structs","_this2","get","majorStruct","majorStructName","i","length","result","mergeStruct","concat","set","foo","trial","_tryParseIdMap","struct","d","structWithSameName","pascalCase","_defaultName","trialMerge","tryMergeStruct","parentKey","keys","every","item","values","_this3","valueType","isTypeOfObject","type","startsWith","endsWith","typeA","typeB","diffStructs","unchageFields","addedFields","removedFields","doMergeStruct","diffLines","replaceAll","change","added","push","parseBackToKeyValue","removed","mapRemoved","fromEntries","str","split","filter","json","JSON","parse"],"mappings":"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"}