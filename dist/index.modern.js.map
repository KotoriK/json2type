{"version":3,"file":"index.modern.js","sources":["../index.ts"],"sourcesContent":["/**\n * json2type\n * @author KotoriK\n * @date 2021.6\n * @license MIT\n */\nimport { pascalCase } from 'change-case'\nimport { diffLines } from 'diff'\ninterface InterfaceDefinition {\n    name: string\n}\nexport class Json2Type {\n    /**\n     * @private\n     * @type {Map<string,InterfaceDefinition>}\n     */\n    private _cache: Map<string, InterfaceDefinition> = new Map()\n    private _cache_r: Map<string, string> = new Map()\n    /**\n     * @private\n     * @type {number}\n     */\n    private _unnameCount: number = 0\n    private _printCache() {\n        if (this._cache_r.size > 0) {\n            const entries = Array.from(this._cache_r.entries())\n            return entries.map(([name, key]) => {\n                return `interface ${name}${key}`\n            }).join('\\n')\n        } else {\n            return ''\n        }\n    }\n    /**\n     * \n     * @param {Record<string,any>} obj \n     * @param {string} name\n     */\n    parseToTypes(obj: Record<string, any>, name: string = 'DefaultInterface') {\n        if (typeof obj !== 'object') throw TypeError('param \"obj\" must be an object, but got ' + typeof obj)\n        return `interface ${name}${this._parseObjectToTypes(obj)}\\n${this._printCache()}`\n    }\n    /**\n     * @private\n     * @param obj \n     * @returns {string}\n     */\n    private _parseObjectToTypes(obj: Object): string {\n        return '{\\n' + Object.entries(obj)\n            .map(([key, value]) => {\n                const safekey = wrapKey(key)\n                return `${safekey}:${this._typeof(value, safekey)}`\n            }\n            ).join('\\n') + '\\n}'\n    }\n    /**\n     * 推断数组内部元素的类型\n     * @private\n     * @param {Array} arr \n     * @returns {string}\n     */\n    private _printArrayType(arr: any[]): string {\n        const typesSet = new Set<string>()\n        for (const value of arr) {\n            typesSet.add(_typeOf_NoRecurse(value))\n        }\n        let T\n        for (const value of arr) {\n            typesSet.add(_typeOf_NoRecurse(value))\n        }\n        if (typesSet.size == 1 && typesSet.has('Object')) {\n            typesSet.clear()\n            for (const item of arr) {\n                typesSet.add(this._checkThenParseObject(item))\n            }\n            const types = Array.from(typesSet)\n            if (typesSet.size == 1) T = types.join(' | ')\n            else {\n                const structs = types.map(name => this._cache_r.get(name)) as string[] //值来自于前边返回，肯定在map中有登记\n                let majorStruct = structs[0]\n                let majorStructName = types[0]\n                for (let i = 1; i < structs.length; i++) {\n                    const trialStruct = structs[i]\n                    const result = mergeStruct(majorStruct, trialStruct)\n                    if (result) {\n                        majorStruct = result\n                        majorStructName = majorStructName.concat(types[i])\n                    } else {\n                        T = types.join(' | ')//如果类型不一样直接放弃合并\n                        return `Array<${T}>`\n                    }\n                }\n                for (let i = 0; i < structs.length; i++) {\n                    this._cache.set(structs[i], { name: majorStructName })\n                    this._cache_r.delete(types[i])\n                }\n                this._cache_r.set(majorStructName, majorStruct)\n                T = majorStructName\n            }\n        } else if (arr.length === 0) {\n            T = 'unknown'//空数组无法推断类型\n        } else {\n            T = Array.from(typesSet).join(' | ')\n        }\n        return `Array<${T}>`\n    }\n    /**\n     * @private\n     * @param foo \n     * @param key \n     * @returns \n     */\n    private _checkThenParseObject(foo: Object, key?: string) {\n        if (foo instanceof Array) {\n            return this._printArrayType(foo)\n        } else if (foo != null) {\n            if (key) {\n                const trial = this._tryParseIdMap(foo, key)\n                if (trial) return trial\n            }\n            const struct = this._parseObjectToTypes(foo, /* key */)\n            if (struct.match(/{\\s*}/)) return struct\n            const d = this._cache.get(struct)\n            if (d) {\n                return d.name\n            } else {\n                let name = key ? pascalCase(key.match(/^[\"']\\d/) ? (\"I\" + key) : key) : this._defaultName()\n                let structWithSameName: string | undefined\n                while (structWithSameName = this._cache_r.get(name)/*赋值表达式会返回赋予的值 */) {\n                    //是否可以合并\n                    const trialMerge = tryMergeStruct(structWithSameName, struct)\n                    if (trialMerge) {\n                        //填入新的记录\n                        this._cache.set(trialMerge, { name })\n                        //将两个结构重定向到新的结构\n                        this._cache.set(structWithSameName, { name })\n                        this._cache.set(struct, { name })\n                        this._cache_r.set(name, trialMerge)\n                        break//可以脱出循环了\n                    } else {\n                        //更名\n                        name = name.concat('_')\n                    }\n                }\n                this._cache_r.set(name, struct)\n                this._cache.set(struct, { name })\n                return name\n            }\n        }\n        return 'null'\n    }\n    /**\n     * try to parse Index Signatures Object\n     * @seealso https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures\n     * @param foo \n     * @param key \n     * @returns \n     */\n    private _tryParseIdMap(foo: Object, key: string) {\n        const parentKey = key\n        const keys = Array.from(Object.keys(foo))\n        if (keys.length > 0 && keys.every((item) => item.match(/^\\d+$/))) {\n            return `{[id:number]:${Array.from(\n                new Set(\n                    Object.values(foo)\n                        .map(value => this._typeof(value, parentKey))\n                )\n            )\n                .join('|')}}`\n        }\n    }\n    /**\n     * @private\n     * @param foo \n     * @param {string | undefined} key\n     * @returns {string}\n     */\n    private _typeof(foo: any, key: string): string {\n        let valueType = typeof foo\n        switch (valueType) {\n            case 'object':\n                return this._checkThenParseObject(foo, key)\n            /**按原样 */\n            case \"undefined\":\n            case 'boolean':\n            case 'number':\n            case \"string\":\n                return valueType\n            default:\n                throw valueType + \" isn't support yet.\"\n        }\n    }\n    /**\n     * @private\n     * @returns {string}\n     */\n    private _defaultName(): string {\n        return 'I' + this._unnameCount++\n    }\n}\n/**\n * @param foo \n * @returns {string}\n */\nfunction _typeOf_NoRecurse(foo: any): string {\n    let valueType = typeof foo\n    switch (valueType) {\n        case 'object':\n            return 'Object'\n        /**按原样 */\n        case \"undefined\":\n        case 'boolean':\n        case 'number':\n        case \"string\":\n            return valueType\n        default:\n            throw valueType + \" isn't support yet.\"\n    }\n}\n/**\n * 将key包裹成符合JavaScript标识符要求的格式\n * @param {string} key \n */\nfunction wrapKey(key: string) {\n    //数字打头的Key\n    if (key.match(/^\\d/)) {\n        return `\"${key}\"`\n    } else if (key.match(/[\\u0000-#%-/:-@[-^`{-\\u007f]/)) {//ASCII中没有ID_Start和ID_Continue也不是'$','_'的字符\n        return `\"${key}\"`\n    } else {\n        //非ASCII的用例太罕见，不做处理\n        return key\n    }\n}\n/**\n * 检查一个类型描述是不是描述一个详细的对象（即不object）\n * @param type \n */\nconst isTypeOfObject = (type: string) => type.startsWith('{') && type.endsWith('}')\n\nfunction tryMergeStruct(typeA: string, typeB: string) {\n    if (isTypeOfObject(typeA) && isTypeOfObject(typeB)) {\n        const [unchageFields, addedFields, removedFields] = diffStructs(typeA, typeB)\n        if (unchageFields.length >= (addedFields.length + removedFields.length)) {\n            return doMergeStruct(unchageFields, addedFields, removedFields)\n        }\n    }\n}\nconst mergeStruct = (typeA: string, typeB: string) => doMergeStruct(...diffStructs(typeA, typeB))\n\nfunction diffStructs(typeA: string, typeB: string) {\n    const changes = diffLines(typeA.replaceAll(/^{|}/mg, ''), typeB.replaceAll(/^{|}/mg, ''))\n    const unchageFields = [], addedFields = [], removedFields = []\n    for (const change of changes) {\n        if (change.added) addedFields.push(...parseBackToKeyValue(change.value))\n        else if (change.removed) removedFields.push(...parseBackToKeyValue(change.value))\n        else unchageFields.push(...parseBackToKeyValue(change.value))\n    }\n    return [unchageFields, addedFields, removedFields] as const\n}\nfunction doMergeStruct(unchageFields: string[][], addedFields: string[][], removedFields: string[][]) {\n    //检查类型是否相同\n    const mapRemoved = Object.fromEntries(removedFields)\n    for (const [key] of addedFields) {\n        const typeRemoved = mapRemoved[key]\n        if (typeRemoved/*  && typeRemoved != type */) {\n            return undefined\n        }\n    }\n    //removed和added的字段全部标记可选\n\n    return \"{\\n\" + [\n        ...[...addedFields, ...removedFields].map(([key, type]) => `${key}?:${type}`),\n        ...unchageFields.map(([key, type]) => `${key}:${type}`)\n    ]\n        .join('\\n') + \"\\n}\"\n}\n\nconst parseBackToKeyValue = (str: string) => str.split('\\n').filter(str => str != '').map(str => str.split(':'))\n\n/**\n * \n * @param {string} json\n * @param {string} name name of the generating interface \n */\nexport function parseToTypes(json: string, name: string = 'DefaultInterface') {\n    return new Json2Type().parseToTypes(JSON.parse(json), name)\n}\n"],"names":["Json2Type","_cache","Map","_cache_r","_unnameCount","_printCache","this","size","Array","from","entries","map","name","key","join","parseToTypes","obj","TypeError","_parseObjectToTypes","Object","value","safekey","match","wrapKey","_typeof","_printArrayType","arr","typesSet","Set","add","_typeOf_NoRecurse","T","has","clear","item","_checkThenParseObject","types","structs","get","majorStruct","majorStructName","i","length","result","mergeStruct","concat","set","delete","foo","trial","_tryParseIdMap","struct","d","structWithSameName","pascalCase","_defaultName","trialMerge","tryMergeStruct","parentKey","keys","every","values","valueType","isTypeOfObject","type","startsWith","endsWith","typeA","typeB","unchageFields","addedFields","removedFields","diffStructs","doMergeStruct","changes","diffLines","replaceAll","change","added","push","parseBackToKeyValue","removed","mapRemoved","fromEntries","str","split","filter","json","JSON","parse"],"mappings":"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"}